## 1. 문제 정보 (Problem)

  - **문제 이름**: LCA 2
  - **출처 및 번호**: [백준 11438번]('https://www.acmicpc.net/problem/11438')
  - **난이도**: 플래티넘 5
  - **문제 요약**: M개의 줄에 차례대로 입력받은 두 노드의 가장 가까운 공통 조상 구하기

---
## 2. 핵심 아이디어 (Core Logic)


---
## 3. 어려웠던 점 (Difficulties)
- 시간초과 
- print 매번 호출하면 느림.. -> `'\n'.join(정답 문자열 리스트)` 로 한번에 출력
- 


---
## 4. 새롭게 배운 점 (What I Learned)
### LCA(Least Common Ancestor, 최소 공통 조상)
- LCA란? 두 노드의 공통 조상 중 가장 가까운 노드
- 가장 단순한 방법
  1. 두 노드의 깊이(depth=level)를 똑같이 맞춘다. (더 깊은 애가 부모 쪽으로 한 칸씩 올라감)
  2. 둘 다 한 칸씩 부모 쪽으로 올라간다.
  3. 처음 만나는 노드가 LCA
  - 문제점: 편향 트리일 때 최악, 한 칸씩 올라가는 비효율. -> 시간복잡도 O(N)

### Binary Lifting(이진 리프팅)  => 시간복잡도 O(NlogN + MlogN)  # N은 노드 수, M은 쿼리 수
- 2^k 칸씩 점프 -> 시간복잡도 O(logN)
- 핵심 아이디어: 2^k 점프 테이블
  - 모든 노드에 대해, "나의 2^k 번째 조상이 누구인가?" 미리 다 계산해서 배열에 저장
  - `parent[k][v]` = 노드 v의 2^k번째 조상
  
- 동작 방식
  1. 전처리 : DP 로 2^k 점프 테이블 만들기
      - `parent[0][v]` (1칸 점프) : DFS 돌면서 '직속 부모' 저장
      - `parent[k][v]` (2^k칸 점프) :
        - v의 2^k번째 조상 = v의 2^(k-1)번째 조상의 2^(k-1)번째 조상
      - 전처리 시간 복잡도: O(N log N)
      - 전처리 때 각 노드의 depth도 저장해두기
  2. 쿼리 : LCA 찾기
      1) depth 맞추기 : 두 노드 depth 같아질 때까지 더 깊은 노드 점프시켜서 올리기
      2) 동시에 점프하기
          - k를 큰 값부터 0까지 줄여가면서 2^k 번째 조상이 같은지 확인
          - 다르다면 아직 LCA에 도달하지 않은 것 -> 점프
          - 같다면, 같아지기 직전으로 k 줄여서 점프
      3) 바로 위 부모 `parent[0][v]`가 LCA
      - 쿼리 시간복잡도: O(log N)
      
  

---
## 5. 코드 개선 (Refactoring)

