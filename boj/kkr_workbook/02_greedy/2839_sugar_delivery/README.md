## 1. 문제 정보 (Problem)

  - **문제 이름**: 설탕 배달
  - **출처 및 번호**: [백준 2839번]('https://www.acmicpc.net/problem/2839')
  - **난이도**: 실버 4
  - **문제 요약**: Nkg의 설탕을 5kg, 3kg 단위의 봉지에 나눠담을 때, 가장 적은 봉지 수 구하기

---
## 2. 핵심 아이디어 (Core Logic)
거스름돈 문제들과 다르게, 두 단위가 나누어 떨어지지 않는다.
그리디 알고리즘: 5kg 봉지를 최대한 많이 사용해야, 봉지 수를 적게 쓸 수 있다.
1. 5의 배수인지 확인 -> 3kg 1개 사용 -> 5의 배수 확인 -> 3kg 사용 -> ...
2. 5의 배수가 되거나, 0이 되거나, 0 초과 3 미만으로 남으면 끝.

---
## 3. 어려웠던 점 (Difficulties)
- 큰 단위가 작은 단위의 배수가 아니라서, 큰 단위부터 사용하는 규칙을 적용하면 안 될 것 같았다.
    - 근데 딱히 반례도 모르겠고,, 어떻게 접근해야 할지 모르겠다.
- while문 종료조건 설정과 조건들의 순서가 항상 헷갈린다.

---
## 4. 새롭게 배운 점 (What I Learned)


---
## 5. 코드 개선 (Refactoring)
- 오답 코드
```python
while True:  # 무한 반복
    # 종료 조건 1:  나누어 떨어지지 않으면 -1 할당하고 루프 종료
    if N < 3:
        cnt_pack = -1
        break
    if N % 5 != 0:  # 5의 배수가 아니면,
        N -= 3  # 3 차감
        cnt_pack += 1  # 사용한 봉지 수 1 증가
    # 종료 조건 2:
    else:  # 5의 배수면, 전부 5kg에 담고, 루프 종료.
        cnt_pack += N / 5  # (N / 5)봉지 사용
        break
```

- N이 5의 배수가 아닌 3의 배수일 때, -1 반환..
- N == 0 일 때로 종료조건을 바꿔준다.

- 수정한 코드 (정답)
```python
while True:  # 무한 반복
    # 종료 조건 1: N이 0일 때
    if N == 0:
        break
    # 종료 조건 2:  나누어 떨어지지 않으면 -1 할당하고 루프 종료
    elif N < 3:
        cnt_pack = -1
        break
    if N % 5 != 0:  # 5의 배수가 아니면,
        N -= 3  # 3 차감
        cnt_pack += 1  # 사용한 봉지 수 1 증가

    else:  # 5의 배수면, 전부 5kg에 담고, 루프 종료.
        cnt_pack += N / 5  # (N / 5)봉지 사용
        N = 0
```