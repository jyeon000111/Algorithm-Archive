## 1. 문제 정보 (Problem)

  - **문제 이름**: N과 M (1)
  - **출처 및 번호**: [백준 15649번]('https://www.acmicpc.net/problem/15649')
  - **난이도**: 실버 3
  - **문제 요약**: 1~N 자연수 중에서 중복 없이 M개를 고른 수열을 모두 구하기

---
## 2. 핵심 아이디어 (Core Logic)
- 백트래킹 연습
- 재귀를 이용한 깊이 우선 탐색(DFS)

---
## 3. 어려웠던 점 (Difficulties)
- 함수 매개변수를 어떻게 설정해야 할지 고민되었다.
- 처음에는 수열의 길이 M과 현재 깊이 i를 인자로 받는 함수를 만들었다.
  - 백준 채점 결과 오답!
  - 결과 리스트를 외부에 만들어 '상태의 독립성'을 지키지 못함.
  - result라는 단 하나의 리스트를 모든 재귀 호출이 공유해서, 서로의 상태에 영향을 미치게 됨.


---
## 4. 새롭게 배운 점 (What I Learned)
요약:
- 메모리 효율이 중요할 때(재귀 호출 횟수가 클 때) : 전역 변수로 결과리스트를 두고, append와 pop으로 수정하면서 쓰기
- 안전성과 간결함이 중요할 때: 결과 리스트를 인자로 받고, 재귀 호출 시마다 새 리스트를 생성하여 인자로 넘기며 쓰기. 매 재귀마다 독립적인 리스트를 쓰게 됨.



### 1. 결과 리스트를 인자로 받는 방식
  - '상태의 독립성'을 유지시켜준다. (각 재귀 호출이 독립적인 결과 리스트를 가지도록 한다.)
  - 다음 함수를 호출할 때, 기존 리스트를 수정하지 말고 현재 리스트의 복사본에 새로운 숫자를 더한 새 리스트를 만들어 전달한다.
  - `print_sub(current_suquence + [num])`
  - 결과 리스트의 길이 자체를 깊이로 활용할 수 있다.

>  - 장점: 상태 관리 실수가 원천적으로 차단되어 안전하고 간결함.
>  - 단점: 재귀 호출마다 새 리스트를 생성하므로, 메모리 부담이 크다.


### 2. 결과 리스트를 전역 변수로 두는 방식
  - append / pop 으로 상태관리를 해준다.

> - 장점: 매번 리스트를 새로 만들지 않고, 수정만 하므로, 메모리 사용이 효율적임.
> - 단점: pop() 누락 등 상태 관리 실수의 위험이 있음.

---
- `.append()` : 기존 리스트 수정. (메모리 공간 그대로)
- `+ []` : 새 리스트 생성. (새로운 메모리 공간 할당) 
  - `+` 연산자를 사용한 리스트 연결은 새로운 리스트를 생성하여 반환함.





- visited 리스트는? 
  - 전역변수로 두고 모든 재귀 호출이 공유하는 것이 정석!
  - '하나의 탐험 지도' - 모든 탐색 경로가 이 공유된 지도를 참고해야 함.
- result 리스트는?
  - '각자의 탐험 기록' - 개인 탐험 일지. 각 재귀 호출마다 독립적인 상태를 가지도록 만드는 것이 안전함.
  - 깨끗이 지우고 잘 관리한다는 가정 하에 화이트보드처럼 전역변수로 공유하고 사용해도 되긴 함. (pop() 중요)

- 함수 내에서 전역변수에 직접 접근할 수 있다. 전역변수에 있는 값을 불필요하게 인자로 받을 필요가 없다.




---
## 5. 다양한 풀이 비교 (Comparison of Solutions)
- 풀이 1 (백준 채점 결과 오답)
  - 불필요한 sequence 변수. 인자로 M을 받을 필요 없음.
  - 함수 내에서 바로 전역변수 N과 M에 접근하면 됨.
```python
sequence = [num for num in range(1, N+1)]

result = []
visited = [False] * (N+1)

def print_subsequence(M, i):

    if i == M:  # M개 다 고르면
        print(*result)  # 결과 리스트 언패킹하여 출력
        return
    
    for num in sequence:  # 주어진 N개의 숫자 하나씩 꺼내기
        if not visited[num]:  # 방문한 적 없으면
            result.append(num)  # 결과 리스트에 추가하고
            visited[num] = True  # 방문했다고 표시
                # 방문한 적 있으면 패스
            print_subsequence(M, i+1) # 2개째 선택

            # 다녀와서 직전 방문 없었던 일로 하고 다시 탐색
            result.pop()
            visited[num] = False
```

- 풀이 2
  - 결과 리스트를 함수의 인자로 받아, 재귀호출마다 새로운 결과 리스트를 사용하도록 한다.
  - 결과 리스트의 길이를 깊이로 사용!

```python
N, M = map(int, input().split())
# 목표: 1~N 자연수 중에서 중복 없이 M개를 고른 수열을 모두 구하기

sequence = [num for num in range(1, N+1)]


visited = [False] * (N+1)

def print_sub(current_sub):

    if len(current_sub) == M:  # M개 다 고르면
        print(*current_sub)  # 결과 리스트 언패킹하여 출력
        return
    
    for num in sequence:  # 주어진 N개의 숫자 하나씩 꺼내기
        if not visited[num]:  # 방문한 적 없으면
            visited[num] = True  # 방문했다고 표시
            print_sub(current_sub + [num]) # 결과 리스트에 추가하고, 2개째 선택
            # 방문한 적 있으면, 패스

            # 다녀와서 직전 방문 없었던 일로 하고 다시 탐색
            visited[num] = False

print_sub([])
```