## 1. 문제 정보 (Problem)

  - **문제 이름**: N-Queen
  - **출처 및 번호**: [백준 9663번]('https://www.acmicpc.net/problem/9663')
  - **난이도**: 골드 4
  - **문제 요약**: 크기 N*N 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 방법의 수 출력

---
## 2. 핵심 아이디어 (Core Logic)
1. 좌우 충돌을 피하기 위해 각 행마다 하나씩 놓기
2. 상하 충돌 피하기 위해 visited_col 배열으로 방문 표시
3. 대각선 충돌 방지 -> visited_diag1(행-열), visited_diag2(행+열) 배열로 방문 표시
  - 좌상향 대각선은 행-열 이 일정하고, 우상향 대각선은 행+열 이 일정함

---
## 3. 어려웠던 점 (Difficulties)
- 대각선 방향 검사를 어떻게 할지 고민되었다.
  - 처음엔 델타를 사용해 검사하고자 했다.
  - 이전에 놓은 퀸들의 위치를 기준으로 대각선 위치가 같은지 확인하는 방법이 훨씬 효율적이라는 걸 알게 되었다. (visited_left_diag, visited_right_diag 배열)
    - 좌상향 대각선 규칙: (행 - 열) 값이 일정 
    - 우상향 대각선 규칙: (행 + 열) 값이 일정
    - 포함 여부를 체크할 때는 리스트 보다 set이 효율적!
      - 순서가 없으므로 .remove()로 특정 값 명시해서 제거
        - .pop() 있지만, 순서없이 임의의 요소를 뱉어내므로, 사용X
      - .add() 메서드로 추가


---
## 4. 새롭게 배운 점 (What I Learned)
- `in` 연산의 시간복잡도
  - 리스트에서 O(N)  - 앞에서부터 하나하나 탐색
  - set에서 O(1)  - 해시테이블로 탐색



---
## 5. 코드 개선 (Refactoring)
1. 불필요한 체스판 2차원 배열
```python
chess_board = [[0] * N for _ in range(N)]
```
- 처음엔 대각선 검사를 델타로 하려고 2차원 배열로 생성함.

- 바꾼 방식은 대각선 방향 검사도 행, 열 인덱스만으로 체크하므로, 체스판 배열 자체가 필요하지 않음.
- 충돌 여부 체크를 위한 세 가지 배열(visited_col, visited_left_diag, visited_right_diag)만 있으면 됨.
