## 1. 문제 정보 (Problem)

  - **문제 이름**: 01타일
  - **출처 및 번호**: [백준 1904번]('https://www.acmicpc.net/problem/1904')
  - **난이도**: 실버 3
  - **문제 요약**: 00타일과 1타일로 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지 구하기

---
## 2. 핵심 아이디어 (Core Logic)
- 점화식: N > 2일 때, dp(N) = dp(N-1) + dp(N-2) 
- 기저 조건: dp(1) = 1, dp(2) = 2
- dp(N-1)의 경우에 1타일 하나 붙이는 경우 + dp(N-2)의 경우에 00타일 하나를 붙이는 경우


---
## 3. 어려웠던 점 (Difficulties)
- N == 1일 때의 엣지 케이스를 놓쳤다. 배열의 크기를 너무 타이트하게 잡아두면 인덱스 에러가 발생하기 쉽다.
  - 처음부터 넉넉하게 잡거나, 최소 등의 극단적인 입력값을 입력해보고 조정해야겠다.

---
## 4. 새롭게 배운 점 (What I Learned)
### 1) 모듈러 연산
- 모듈러 연산: 어떤 숫자를 다른 숫자로 나눈 '나머지'에 초점을 두는 계산법
- 모듈러 연산의 성질: 분배법칙 성립(나눗셈 제외)
  1. 덧셈: `(A + B) % C = ((A % C) + (B % C)) % C`
  2. 뺄셈: `(A - B) % C = ((A % C) - (B % C) + C) % C`
  3. 곱셈: `(A * B) % C = ((A % C) * (B % C)) % C`
- 알고리즘에서의 활용: 답이 너무 커지면 나머지를 출력하라는 요구사항이 붙음.
  - 마지막에만 나머지를 구하려고 하면 큰 수 계산 때문에 시간초과, 메모리 초과, 오버플로우 문제 발생
  - 덧셈, 뺄셈, 곱셈이 나올 때마다 모듈러 연산을 해주면, 중간 결과가 항상 C보다 작은 수로 유지됨. 
    -> 계산 속도가 훨씬 빨라짐.

### 2) dp 배열의 위치 : 함수 내부!!!
- 무조건 **함수 내부**에서 생성하는 것이 좋다. (높은 안전성과 단순함 때문)
- 호출할 때마다 깨끗한 상태에서 재시작하므로 버그 발생 확률이 매우 낮다.
- 테스트케이스가 여러 개인 경우, 중복연산을 하게 된다. 그렇더라도 dp 배열을 N번 채우는 것은 비용이 저렴하다. -> 코딩테스트에서 시간 초과가 날 가능성 거의 없음.
- 중복연산을 피하고자 dp 배열을 외부에 두면 오히려 코드가 복잡해지고 버그 발생 확률이 높아진다. -> 약간의 성능 향상을 위해 감수해야 할 위험이 높음.

### 3) 점화식 (Recurrence Relation)
- 개념: 어떤 문제를 자기 자신보다 더 작은 크기의 똑같은 문제로 표현하는 공식  (like 마트료시카)
- 무한 반복 방지를 위해  **기저 조건(Base Case)**이 필수!
- 기저 조건: 답이 명확하게 정해진 가장 작은 문제
- 구현 방식 
  - Top-down: 점화식 설계도 그대로 재귀 호출
    ```python
    def solve(n):
        return solve(n-1) + solve(n-2)
    ```
  - Bottom-up: 기저 조건에서 시작해서 for 반복문으로 쌓아 올림. (설계도 보고 가장 작은 재료부터 조립)
    ```python
    dp[1] = 1
    dp[2] = 2
    for i in range(3, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    ```
    - 이 방식은 함수 없이도 구현 가능하지만, 함수로 만드는 것이 표준적이고 좋은 습관!
    - 함수로 만들어야 하는 이유
      1. 재사용성
      2. 가독성 -코드의 구조화
      3. 안정성 -변수 관리(스코프)
        - 함수 안에 있는 변수들은 함수가 끝나면 깔끔하게 사라짐.
        - 다른 코드와 충돌하지 않아 버그 확률을 낮춰줌.



---
## 5. 코드 개선 (Refactoring)
- 이전 코드
```python
N = int(input())
dp = [0] * (N+1)  # 수열의 길이를 인덱스로 2진수열의 개수를 저장

def dynamic_programming(n):
    dp[1] = 1
    dp[2] = 2
    for i in range(3, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

print(dynamic_programming(N) % 15746)
```

- 문제점 
1. N == 1 일 때, dp의 길이는 2인데, dp[2]에 접근하면서 인덱스 에러 발생.
  -> 리스트 크기 더 넉넉하게 잡기
2. N이 커질수록 dp에 저장되는 값이 매우 커져서 계산 속도가 매우 느려짐.
  -> 모듈러 연산의 성질을 이용해, dp 배열에 값을 저장할 때마다 나머지 연산해서 저장
3. dp 배열이 함수 밖에 있음.
  -> dp 배열의 생성과 수정은 함수 안에서 이루어져야 함수가 독립적으로 작동할 수 있음. (캡슐화)

- 최종 코드
```python
N = int(input())

def dynamic_programming(n):
    dp = [0] * (n+2)  # 수열의 길이를 인덱스로 (2진수열의 개수 % 15746)를 저장
    dp[1] = 1
    dp[2] = 2
    for i in range(3, n+1):
        dp[i] = (dp[i-1] + dp[i-2]) % 15746
    return dp[n]

print(dynamic_programming(N))
```