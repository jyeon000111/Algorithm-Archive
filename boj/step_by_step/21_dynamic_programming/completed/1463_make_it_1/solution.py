# 목표: 정수 N을 3 또는 2로 나누거나 1을 빼서 1을 만든다. 연산 횟수의 최솟값 구하기.
# (단, 나눌 때는 3 또는 2의 배수여야 한다.)

# 3 나누기, 2 나누기, 1 빼기 순으로 적용하는 게 빠르다???
# -> 1을 빼서 3의 배수로 적절히 바꿔주는 경우가 더 빠를 수도
# -> 결국엔 완전탐색으로 다 해봐야 암.
# -> 탐색 횟수 줄이기 위해 메모이제이션.
# -> memo = {나온 숫자: 연산횟수} 딕셔너리로 저장 -> 최소연산횟수로 갱신하며 저장, 메모된 연산횟수 이상이면 가지치기

def dfs(x, cnt):
    '''
    정수 x를 인자로 받아,
    1이 될 때까지 세 가지 연산을 반복하고,
    최소 연산 횟수를 갱신하는 함수입니다.
    메모이제이션으로 가지치기합니다.
    '''
    global min_ans
    if cnt >= min_ans:  # 현재까지의 최소연산횟수 이상이면 가지치기
        return
    if x == 1:
        min_ans = cnt  # 위에서 걸러졌으므로 조건 확인 없이 갱신

    if memo.get(x):  # 나온 적 있는 숫자인 경우
        if cnt >= memo[x]:  # 기록된 연산횟수보다 많으면 가지치기
            return
    # 더 적은 연산횟수로 도달했으면 갱신 + 나온 적 없는 숫자인 경우에도 갱신
    memo[x] = cnt


    if x % 3 == 0:  # 1. 3으로 나누기
        dfs(x//3, cnt + 1)
    if x % 2 == 0:  # 2. 2로 나누기
        dfs(x//2, cnt + 1)

    dfs(x-1, cnt + 1)  # 1 빼기



N = int(input())
min_ans = float('inf')
memo = dict()
dfs(N, 0)

print(min_ans)