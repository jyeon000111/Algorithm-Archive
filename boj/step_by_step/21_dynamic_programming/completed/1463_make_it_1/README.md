## 1. 문제 정보 (Problem)

  - **문제 이름**: 1로 만들기
  - **출처 및 번호**: [백준 1463번]('https://www.acmicpc.net/problem/1463')
  - **난이도**: 실버 3
  - **문제 요약**: 정수 N을 3 또는 2로 나누거나 1을 빼서 1을 만든다. 연산 횟수의 최솟값 구하기.

---
## 2. 핵심 아이디어 (Core Logic)
1. DFS + 메모이제이션 백트래킹
2. DP Bottom-Up 방식

---
## 4. 새롭게 배운 점 (What I Learned)
### 최단 경로 구하는 접근법
- 시간 복잡도는 세 방법 모두 O(N)으로 동일하지만, 실제 실행 속도와 안정성에서 차이 발생.

#### 1. Bottom-up DP
 - 속도: 가장 빠름
 - 장점: 최고의 성능과 안정성
 - 단점: DP 테이블을 1부터 N까지 모두 채워야 함.
 - 구현: dp 배열을 작은 수(0 또는 1?)부터 N까지 채워나감. dp[i]는 i를 1로 만드는 최소 연산 횟수
 - 추천 상황: 간단한 DP 문제, 속도가 중요할 때
    
#### 2. BFS  => 대부분의 경우 가장 적합함. 
 - 속도: 중간
 - 장점: 코드가 간결함. 가지치기 불필요. 구조 자체가 최소 연산 보장!
 - 단점: 너비 기준 탐색이라 메모리 사용량이 많을 수 있음. 큐에 데이터 넣고 빼는 과정에서 약간의 오버헤드.
 - 추천 상황: 가중치 없는 그래프의 최단 경로 문제

#### 3. DFS + 메모이제이션 (Top-down DP)
 - 속도: 느림
 - 장점: 직관적
 - 단점: 재귀 호출 오버헤드가 크다. N이 커지면 재귀 깊이 제한에 걸릴 수 있음.
 - 추천 상황: 복잡한 상태 공간을 가진 DP 문제

### 오버헤드와 시간복잡도
- 시간복잡도가 같을 때, 오버헤드가 실제 속도를 결정한다! (N이 작을수록 영향이 크다.)
- 시간복잡도가 다를 때, 오버헤드는 무시해도 될 정도로 영향이 미미하다.

#### 1. 오버헤드 (Overhead)
- 추가로 소요되는 간접적인 시간, 메모리
- 실제 성능에 영향을 미치는 부가적인 비용
- 예시:
   - 함수 호출: 재귀 함수의 스택
   - 자료구조: 큐에 데이터를 넣고 빼는 내부적인 처리 시간
   - 메모리 할당
   
#### 2. 시간복잡도 (Time Complexity)
- 입력 크기(N)가 커질 때, 연산 횟수가 얼마나 빠르게 증가하는가를 나타내는 **성장률**
- 거시적, 장기적인 효율성


---
## 5. 코드 개선 (Refactoring)
1. 첫번째 풀이: DFS + 메모이제이션
```python
def dfs(x, cnt):
    '''
    정수 x를 인자로 받아,
    1이 될 때까지 세 가지 연산을 반복하고,
    최소 연산 횟수를 갱신하는 함수입니다.
    메모이제이션으로 가지치기합니다.
    '''
    global min_ans
    if cnt >= min_ans:  # 현재까지의 최소연산횟수 이상이면 가지치기
        return
    if x == 1:
        min_ans = cnt  # 위에서 걸러졌으므로 조건 확인 없이 갱신

    if memo.get(x):  # 나온 적 있는 숫자인 경우
        if cnt >= memo[x]:  # 기록된 연산횟수보다 많으면 가지치기
            return
    # 더 적은 연산횟수로 도달했으면 갱신 + 나온 적 없는 숫자인 경우에도 갱신
    memo[x] = cnt

    if x % 3 == 0:  # 1. 3으로 나누기
        dfs(x//3, cnt + 1)
    if x % 2 == 0:  # 2. 2로 나누기
        dfs(x//2, cnt + 1)

    dfs(x-1, cnt + 1)  # 1 빼기

N = int(input())
min_ans = float('inf')
memo = dict()
dfs(N, 0)

print(min_ans)
```

2. 두번째 풀이: Bottom-Up DP 
```python
N = int(input())

dp = [0] * (N+10)  # 인덱스 i에 i를 1로 만들기 위한 최소 연산 횟수 저장 (인덱스 에러 막기 위해 넉넉하게)
dp[2] = 1
dp[3] = 1
for i in range(4, N+1):
    # 1을 빼는 경우
    cnt1 = dp[i-1] + 1
    cnt2 = float('inf')  # 2, 3의 배수가 아닌 경우를 위한 초기화
    cnt3 = float('inf')
    # 2로 나누는 경우
    if i % 2 == 0:
        cnt2 = dp[i // 2] + 1
    # 3으로 나누는 경우
    if i % 3 == 0:
        cnt3 = dp[i // 3] + 1
    # 위 세 가지 경우의 최솟값 저장
    dp[i] = min(cnt1, cnt2, cnt3)

print(dp[N])
```

- 개선할 점: dp[2], dp[3]도 일반화 가능 / cnt1, 2, 3 변수와 무한대 초기화 없이 단계별로 갱신하는 방식 사용

```python
N = int(input())

dp = [0] * (N+10)  # 인덱스 i에 i를 1로 만들기 위한 최소 연산 횟수 저장 (인덱스 에러 막기 위해 넉넉하게)

for i in range(2, N+1):
    # 1을 빼는 경우로 초기화
    dp[i] = dp[i-1] + 1

    # 2로 나누는 경우 -> 갱신
    if i % 2 == 0:
        dp[i] = min((dp[i // 2] + 1), dp[i])
    # 3으로 나누는 경우 -> 갱신
    if i % 3 == 0:
        dp[i] = min((dp[i // 3] + 1), dp[i])

print(dp[N])
```