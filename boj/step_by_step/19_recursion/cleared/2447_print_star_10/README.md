## 1. 문제 정보 (Problem)

  - **출처 및 번호**: [백준 2447번]('https://www.acmicpc.net/problem/2447')
  - **난이도**: 골드 5
---
## 2. 핵심 아이디어 (Core Logic)
- 재귀Recursion 활용
- N*N 패턴을 9개의 (N/3)*(N/3) 크기의 작은 패턴으로 나눈다.
- 가운데 정사각형은 공백으로 비워두고, 나머지 8개 정사각형에 대해 재귀적으로 함수를 호출한다.
- 함수의 인자로, 사각형의 크기, 시작점의 행, 열 인덱스가 필요하다.
- 재귀의 종료 조건: N=1일 때, 해당 위치에 '*' 찍기


---
## 3. 어려웠던 점 (Difficulties)
- 처음엔 2차원 배열을 전부 '*'로 채워놓고, 공백을 뚫는 방식으로 접근했다.
  - 예상과 달리 코드가 복잡해졌다. 공백을 뚫는 위치를 계산하는 어려움..

- 2차원 배열을 전부 ' ' 공백으로 채워놓고, 필요한 위치에만 '*'을 찍는 방식으로 바꾸었다.
  - 재귀 함수가 '별을 찍는 역할'만 하게 되어, 논리가 단순해졌다. 
  
- 출력형식 때문에 오답이 되었다.
  - *로 리스트를 언패킹하면 문자 사이에 공백이 들어간다!
  - `''.join()`으로 공백 없이 이어붙여줘야 한다.


---
## 4. 새롭게 배운 점 (What I Learned)
- 재귀 함수의 종료 조건에서 return 을 명시해야 한다.
  - 무한 재귀 방지, 올바른 흐름 유지



---
## 5. 코드 개선 (Refactoring)
- 이전 코드
```python
# 2. 주변 8개 정사각형 그리기
# 좌상단 모서리 기준점 리스트에 담기
start_8_idx = []
for i in [0, N//3, N//3*2]:
    for j in [0, N//3, N//3*2]:
        if i == N//3 and j == N//3:
            continue
        start_8_idx.append((i, j))

# 각 모서리에 대해서, 재귀호출해서 패턴 그리기
for i, j in start_8_idx:
    draw_pattern(N//3, row_idx+i, col_idx+j)
```

- 리스트를 생성해서 불필요한 반복을 했다.
- 재귀호출할 9등분한 정사각형의 사이즈를 이용해 가독성을 높일 수 있다.

- 개선한 코드
```python
# 2. 주변 8개 정사각형 그리기
# 좌상단 모서리 기준점 반복문으로 뽑아내기
small_size = N//3
for i in range(3):
    for j in range(3):
        if i == 1 and j == 1: # 가운데 사각형 제외
            continue  
        # 각 모서리에 대해서, 재귀호출해서 패턴 그리기
        new_i = row_idx + i * small_size
        new_j = col_idx + j * small_size
        draw_pattern(small_size, new_i, new_j)
```

