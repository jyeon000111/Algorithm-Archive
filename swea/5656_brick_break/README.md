## 1. 문제 정보 (Problem)

  - **문제 이름**: 5656. [모의 SW 역량테스트] 벽돌 깨기
  - **출처 및 번호**: [SWEA 5656번]('URL주소')
  - **난이도**:
  - **문제 요약**: 구술 N개를 떨어뜨려 최대한 많은 벽돌을 제거할 때, 남은 벽돌의 개수 구하기

---
## 2. 핵심 아이디어 (Core Logic)
- 남은 벽돌의 최솟값 구하기
    - 완전 탐색, 백트래킹하면서 갱신
=> N, W, H의 최대입력값이 크지 않으므로, 이중리스트로 구현해도 됨!
1. 백트래킹 함수:
    - 열마다 구슬 떨어뜨려보고, 재귀호출로 다음 구슬로 넘어가기. 다녀와서 원상복구
    - 원상복구는 for문 시작할 때마다 원본 배열을 deepcopy해서 해결
    - 구슬 N개를 다 사용하면 남은 벽돌 계산해서 갱신하고 return
    - (예외 처리) 구슬 다 사용하기 전에 벽돌 다 제거한 경우 처리
2. 벽돌 깨뜨리기 함수(BFS):
    - 백트래킹 함수에서 열에 구슬 떨어뜨릴 때 호출
    - 깨뜨릴 벽돌을 deque 자료구조에 담아 순차적으로 연쇄작용으로 벽돌 제거
3. 벽돌 재정렬 함수:
    - 0으로 초기화된 새 배열 만들기
    - 열마다 숫자 찾아서 stack에 담기
    - 역순으로 새 배열에 찾은 숫자 pop해서 입력
        

---
## 3. 어려웠던 점 (Difficulties)
1. 매번 이중리스트의 상태를 변경하면서 해도 시간 초과나 메모리 초과 나지 않는 건가 싶어 고민되었다.
2. 배열을 변경하고 원상복구를 어떻게 해야할지 어려웠다.
    - for문 시작할 때마다 초기화해주는 효율적인 방법을 배웠다.
3. 벽돌 깨뜨리는 과정이 복잡해 따로 함수를 만들어야겠다는 생각은 했지만, 구현이 어려웠다.
    - BFS를 이런 식으로도 활용할 수 있구나. 연쇄작용을 처리할 때 좋은 방법
4. 마지막에 9로 채워진 테스트케이스만 오답이 나와서 디버깅에 많은 시간이 소요됐다.
    - 구슬 N개를 모두 사용했을 때만 최솟값을 갱신해서, 그 전에 벽돌이 다 제거된 경우 문제가 생겼다.
    - 백트래킹 함수 시작할 때, 남은 벽돌이 0개인지 체크해서 그 경우 최솟값을 0으로 갱신하고 return하는 부분을 추가했다.

    
---
## 4. 새롭게 배운 점 (What I Learned)
- 입력값 범위가 작게 주어지는 경우 완전 탐색을 해도 된다는 신호라는 것을 새로 배웠다.
- 어떤 현상이 시작점으로부터 단계적으로 퍼져나가는 문제를 만나면 BFS를 가장 먼저 떠올리면 좋다.
    - 동시에 파동처럼 퍼져나가는 연쇄작용 구현에 효율적!

---
## 5. 코드 개선 (Refactoring)

